
Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1.Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
 
    Это команда встройенная.
    Внвстроенная, потому что, работать внутри сессии терминала логичнее менять указатель на текущую дерикторию внутренней функцией, 
    Еслииспользовать внешний вызов, то он будет работать со своим окружением, и менять  текущий каталог внутри своего окружения, а на вызвовший shell влиять не будет. 
        
2.Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
 
     grep -c <some_string> <some_file>
   
3.Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

    1 ?        Ss     0:01 /sbin/init

4.Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
        
    # tty
    /dev/pts/3
    № ls some_file  2> /dev/pts/1
    
    $ ls: cannot access 'some_file': No such file or directory
    # tty
    $ /dev/pts/1

5.Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
    
    cat < some_file > some_file
    
      
6.Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
        
    # tty
    /dev/pts/3
    # echo netology > /dev/tty3
    
    вывод можно увидлеть но только передя на Ctrl-Alt-F3
     
        


7.Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

    bash 5>&1 - Создаст дескриптор с 5 и перенатправит его в stdout
    echo netology > /proc/$$/fd/5 - выведет в дескриптор "5", который был пернеаправлен в stdout
      
8.Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
    
    ls -l /root 5>&2 2>&1 1>&5 |grep denied
9.Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

    env
    printenv


10.Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

    /proc/<PID>/cmdline - полный путь до исполняемого файла процесса [PID]  (строка 231)
    /proc/<PID>/exe - содержит ссылку до файла запущенного для процесса [PID], 
                            cat выведет содержимое запущенного файла, 
                            запуск этого файла,  запустит еще одну копию самого файла  (строка 285)
    1.Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
11.Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo            
     
    cat /proc/cpuinfo |   grep flags | sort -u | xargs -n 1  | grep ^sse
        sse
        sse2
        sse4_1
        sse4_2

12.При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

 vagrant@netology1:~$ ssh localhost 'tty'
not a tty
   

13.Почитайте, почему так происходит, и как изменить поведение.

     при подключении ожидается пользователь, а не другой процесс, и нет локального tty в данный момент. 
     добавить -t - , и команда исполняется c принудительным созданием псевдотерминала

14.Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
    
    # ps uax | grep cmd
    serz     19254  0.0  0.0  35744  8380 pts/3    S+   23:57   0:00 vim cmd_yes.sh
    # reptyr 19254    
    serz     19254  0.0  0.0  35744  8616 pts/5    Ss+  Jan23   0:00 vim cmd_yes.sh

    
15.sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
    
     команда tee делает вывод одновременно и в файл, указаный в качестве параметра, и в stdout, 
     в данном примере команда получает вывод из stdin, перенаправленный через pipe от stdout команды echo
     и так как команда запущена от sudo , соотвественно имеет права на запись в файл